#this file id generated by AI to auto run python files on save

import os
import sys
import time
import subprocess
import re
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

BASE_DIR = os.path.dirname(os.path.abspath(__file__))

IGNORE_DIRS = {".venv", "__pycache__", ".git", "images"}
IGNORE_FILES = {"tempCodeRunnerFile.py"}
DEBOUNCE_SECONDS = 0.5

# If True: when you save a file without __main__, it will run main.py.
# If False: it will just ignore those files (recommended for your case). 
FALLBACK_TO_MAIN = False
MAIN_FILE = os.path.join(BASE_DIR, "main.py")


MAIN_GUARD_RE = re.compile(r"""if\s+__name__\s*==\s*['"]__main__['"]\s*:""")


def in_ignored_dir(path: str) -> bool:
    parts = set(os.path.normpath(path).split(os.sep))
    return bool(parts & IGNORE_DIRS)


def should_watch(path: str) -> bool:
    path = os.path.normpath(path)
    if in_ignored_dir(path):
        return False
    if not path.lower().endswith(".py"):
        return False
    if os.path.basename(path) in IGNORE_FILES:
        return False
    return True


def has_main_guard(py_file: str) -> bool:
    try:
        with open(py_file, "r", encoding="utf-8", errors="ignore") as f:
            txt = f.read()
        return bool(MAIN_GUARD_RE.search(txt))
    except Exception:
        return False


class RunOnSave(FileSystemEventHandler):
    def __init__(self):
        self.p = None
        self.last = 0
        print("✅ Watcher started from:", BASE_DIR)
        print("✅ Save a runnable .py file (with __main__) to run it. Ctrl+C to stop.\n")

    def run(self, target: str):
        target = os.path.abspath(target)

        if self.p and self.p.poll() is None:
            self.p.terminate()
            try:
                self.p.wait(timeout=2)
            except subprocess.TimeoutExpired:
                self.p.kill()

        print(f"▶ Running: {os.path.basename(target)}")
        self.p = subprocess.Popen([sys.executable, target], cwd=BASE_DIR)

    def _handle_path(self, path: str):
        now = time.time()
        if now - self.last < DEBOUNCE_SECONDS:
            return

        if not should_watch(path):
            return

        self.last = now
        abs_path = os.path.abspath(path)

        # Must be inside project folder
        if not abs_path.startswith(os.path.abspath(BASE_DIR)):
            return

        runnable = has_main_guard(abs_path)
        print(f"✏️ Saved: {os.path.basename(abs_path)} | __main__ = {runnable}")

        if runnable:
            self.run(abs_path)
        else:
            if FALLBACK_TO_MAIN and os.path.exists(MAIN_FILE):
                print("↪ No __main__ → running main.py")
                self.run(MAIN_FILE)
            else:
                print("⏭ No __main__ → ignoring (no restart)\n")

    def on_modified(self, event):
        if not event.is_directory:
            self._handle_path(event.src_path)

    def on_created(self, event):
        if not event.is_directory:
            self._handle_path(event.src_path)

    def on_moved(self, event):
        # VS Code safe-write often triggers this
        if hasattr(event, "dest_path") and not event.is_directory:
            self._handle_path(event.dest_path)


if __name__ == "__main__":
    handler = RunOnSave()
    obs = Observer()
    obs.schedule(handler, BASE_DIR, recursive=True)
    obs.start()

    try:
        while True:
            time.sleep(1)
    except KeyboardInterrupt:
        obs.stop()
        if handler.p and handler.p.poll() is None:
            handler.p.terminate()

    obs.join()
